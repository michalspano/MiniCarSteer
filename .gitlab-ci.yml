# .gitlab-ci.yml
image: docker:26.0.0-dind-alpine3.19

# Details about how to connect to the Docker service to run this build.
variables:
  DOCKER_HOST: tcp://docker:2375
  DOCKER_TLS_CERTDIR: ""

# Services are other images run as their own container on the pipeline
# We have docker in docker service, meaning that a container that has docker installed on it
services:
  - name: docker:26.0.0-dind

# We have two stages: build stage which is used to build and test the application
# and deploy which is used to deploy the application's docker image and make a release
stages:
  - build
  - deploy

# Executed before the script
before_script:
  - docker info
  - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY

  # Get new repository package updates
  - apk update

# This section describes what shall be done to build and test the project.
build-and-test:
  # We use docker-build to use the runner that can compose docker containers
  tags:
    - docker-build
  stage: build
  # Build-and-test job is only executed for branch commits
  only:
    - branches
  # Build the docker image using the Dockerfile in the root of the repository
  before_script:
    # Install python as it is needed to run our app and pip for downloading dependencies
    # Venv is needed to install requirement sin a virtual environment rather than globally
    # mesa-gl is needed for opencv to work
    # GCC is needed to install opencv
    - apk add --no-cache python3 py3-pip py3-virtualenv mesa-gl build-base
  script:
    # Create the virtual environment and call it venv
    - python3 -m venv venv
    # Enter venv
    - . ./venv/bin/activate
    # Upgrade pip
    - pip install --upgrade pip
    # Install dependencies on the venv
    - pip install --no-cache-dir --no-deps -r requirements.txt
    # Run the app. (needs to be done in src as the files contains other module paths)
    - cd src && python3 app.py
    # Change back to project root and exit venv
    - cd .. && deactivate
    # Build the docker image of our app
    - docker build --rm -f Dockerfile -t read_car_data .s
  # artifacts:
  #   paths:

# This section describes what shall be done to deploy artifacts from the project.
release_job:
  tags:
    - docker-build
  stage: deploy
  # The job is run on tag commits only
  only:
    - tags
  before_script:
    # curl is needed to download the release-cli
    - apk add curl

    # Install release-cli to make releases
    - curl --location --output /usr/local/bin/release-cli "https://gitlab.com/api/v4/projects/gitlab-org%2Frelease-cli/packages/generic/release-cli/latest/release-cli-linux-amd64"

    # Gie executable permissions to release-cli
    - chmod +x /usr/local/bin/release-cli
  # Check that the tag commit name follows semantic versioning by checking it with the regex that makes sure 
  # the tag commit name is in the form of vX.Y.Z where X, Y, and Z are numbers
  # If the tag commit name follows semantic versioning build the using the provided version as name
  # If not, write error message and exit with code 1 to indicate failure
  script:
    - |
      # Verify the format of the tag commit name.
      # `\d+` to denote a digit is not part of basic regular expressions. We
      # pass the `-E` flag to `grep` to parse an extended regular expression
      # that supports `\d+`. This makes the solution more flexible and can
      # support any number and not just 0 through 9 (if [0-9] is used).
      if echo "$CI_COMMIT_TAG" | grep -E '^v\d+\.\d+\.\d+$' > /dev/null; then
        echo "Version is valid."
        docker build -f Dockerfile -t "$CI_REGISTRY_IMAGE":"$CI_COMMIT_TAG" .
        docker push "$CI_REGISTRY_IMAGE":"$CI_COMMIT_TAG"
      else
        echo "Version is invalid."
        echo "$CI_COMMIT_TAG"
        exit 1
      fi
  # Make a release that has the version as its name and description
  release:
    tag_name: '$CI_COMMIT_TAG'
    description: '$CI_COMMIT_TAG'
